### dbg_min
```cpp
//./dbg_func/dbg_min.cpp
     1	#include <bits/stdc++.h>
     2	using namespace std;

     3	#define show(arg) cerr << "\033[36m" << #arg << "\033[0m = " << arg << endl;
     4	#define dbg(...) debug(string(#__VA_ARGS__).begin(), __VA_ARGS__)

     5	void debug(string::iterator it) {
     6	    cerr << endl;
     7	}

     8	void debug(string::iterator it, auto a, auto... args) {
     9	    cerr << "\033[36m";
    10	    int cnt = 0;
    11	    while (*it != ',' || cnt) {
    12	        if (*it == '(' || *it == '{') cnt++;
    13	        if (*it == ')' || *it == '}') cnt--;
    14	        if (*it != ' ') cerr << *it;
    15	        ++it;
    16	    }
    17	    cerr << "\033[0m"
    18	         << " = " << a << "   ";
    19	    debug(++it, args...);
    20	}
 
```
### HEOI2005
```
在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。

一个串的“子串”指的是它的连续的一段，例如bcd是abcdef的子串，但bde不是。
一个串的“子序列”指的是它的可以不连续的一段，例如bde是abcdef的子串，但bdd不是。
下面，给两个小写字母串A，B，请你计算：
(1) A的一个最短的子串，它不是B的子串
(2) A的一个最短的子串，它不是B的子序列
(3) A的一个最短的子序列，它不是B的子串
(4) A的一个最短的子序列，它不是B的子序列
输入
有两行，每行一个小写字母组成的字符串，分别代表A和B。

输出
输出4行，每行一个整数，表示以上4个问题的答案的长度。如果没有符合要求的答案，输出-1
```
### luogu4148
```
你有一个N \times N的棋盘，每个格子内有一个整数，初始时的时候全部为 00，现在需要维护两种操作：

1 x y A, 1 ≤ x, y ≤ N , A 是正整数。将格子 x,y 里的数字加上 A。
2 x1 y1 x2 y2, 1 ≤ x1 ≤ x2 ≤N 1 ≤ y1 ≤ y2 ≤ N。输出 x1, y1, x2, y2 这个矩形内的数字和
3 无 终止程序
输入格式
输入文件第一行一个正整数 N。

接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 last_ans，初始时 last_ans = 0。

输出格式
对于每个 2 操作，输出一个对应的答案。
```
### luogu3809
```
读入一个长度为 n 的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序（用 ASCII 数值比较）从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 1 到 n。
```
### luogu1494
```
作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……

具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。

你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

然而数据中有L=R的情况，请特判这种情况，输出0/1。

输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。

包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。
```
### luogu3804
```
给定一个只包含小写字母的字符串 S ,请你求出 S 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。
```
### cf932G
```
给定一个串，把串分为偶数段
假设分为了s1,s2,s3…sk
求，满足s1=sk,s2=sk−1… 的方案数。

当你把原串S变成S′=S[1]S[n]S[2]S[n−2]… 后，这题的问题就变成了有多少种切分S’的方法使得每一段都是回文串。

（这个转化已经很神仙了，这道题就出到这里我都觉得已经很nb了）

回文切分方法这个东西是一个经典的n方dp，dp[i]表示当前前缀i有多少种切分方法，dp[i]要从i的所有后缀回文位置dp[j]转移过来，累加就是当前dp[i]的答案。

这时候你就需要一个玩意儿帮你搞定当前前缀i位置的所有回文后缀。考虑使用回文树，首先找到前缀i位置对应的回文树节点，之后向上一条fail链就是当前位置的所有后缀回文，当fail树整个是一条链的时候，复杂度退化到n方。

然而这题的串长1e6，n方显然是远远做不动的，需要想办法优化。

怎么办呢？翻开金策-字符串算法选讲，翻到23页，就提到了这个dp的优化，而且讲了一些很nb的知识…

s 是回文串, 则 s 的后缀 t 是回文串当且仅当 t 是 s border。

也就是说如果一个回文串的后缀也是一个回文，那么这个后缀一定跟该回文串的相同长度前缀相等。

既然这样就可以利用一下border的性质。

一个字符串的所有回文后缀的长度可以表示成 O(logn)个等差数列。

忽然很nb的做法就诞生了…

根据这两条结论，我们发现一条fail链的组成是有规律的，它可以划分成logn个等差数列。

这是一组等差回文后缀，设当前位置为i，最长的一个后缀长度为a1，公差为d，那么根据border的性质可以知道s[i - a1,i - d]是一个回文串，s[i - a2,i - d]也是一个回文串…一直到等差数列的最后一项，这个时候[i - an,i - d]就不再是回文串了。

也就是说，在i这个位置，我们想求的分割数，其实和其在回文树上的fail位置之差了一个等差数列的末项没有统计（前提是fail还在同一个等差数列内）！

有了这个结论之后，就可以愉快的按等差分组，一组一组的转移了。
```
